"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ava_1 = require("ava");
const path_1 = require("./path");
function combinePathMacro(t, parent, relativePath, expected) {
    t.is(path_1.combinePath(parent, relativePath), expected);
}
combinePathMacro.title = (_title, parent, relativePath, expected) => `combinePath(${parent}, ${relativePath}) is ${expected}`;
ava_1.default(combinePathMacro, '/', 'wow', '/wow');
ava_1.default(combinePathMacro, '/', 'foo/bar', '/foo/bar');
ava_1.default(combinePathMacro, '/foo/', 'bar', '/foo/bar');
ava_1.default(combinePathMacro, 'foo/', 'bar', 'foo/bar');
ava_1.default(combinePathMacro, '/foo/', '/', '/');
ava_1.default(combinePathMacro, '/foo/', '/bar', '/bar');
ava_1.default(combinePathMacro, '/foo/', '..', '/');
ava_1.default(combinePathMacro, '/foo/bar', '..', '/');
ava_1.default(combinePathMacro, '/foo/bar/', '../..', '/');
ava_1.default(combinePathMacro, '/foo/bar/stuff', '../..', '/');
ava_1.default(combinePathMacro, '/foo/bar/stuff/', '../..', '/foo/');
ava_1.default(combinePathMacro, '/foo/', '../bar', '/bar');
ava_1.default(combinePathMacro, '/foo/', '.', '/foo/');
ava_1.default(combinePathMacro, '/foo/bar', '.', '/foo/');
ava_1.default(combinePathMacro, '/foo', 'bar', '/bar');
ava_1.default('combinePath fails on relative ./', t => {
    t.throws(() => path_1.combinePath('/whatever/', './'), { message: /\.\// });
});
ava_1.default('combinePath fails on empty relative', t => {
    t.throws(() => path_1.combinePath('/whatever/', ''), { message: /empty string is not a relative path/ });
});
ava_1.default('getMenuOfPath with already menu', t => {
    t.is(path_1.getMenuOfPath('/'), '/');
    t.is(path_1.getMenuOfPath('/foo/'), '/foo/');
    t.is(path_1.getMenuOfPath('/foo/bar/'), '/foo/bar/');
});
ava_1.default('getMenuOfPath with child', t => {
    t.is(path_1.getMenuOfPath('/foo'), '/');
    t.is(path_1.getMenuOfPath('/foo/bar'), '/foo/');
});
ava_1.default('getMenuOfPath throws when not a path', t => {
    t.throws(() => path_1.getMenuOfPath('foo'), { message: /not .+ a path/ });
});
ava_1.default('createRootMenuTrigger does not throw on good trigger', t => {
    t.notThrows(() => {
        path_1.createRootMenuTrigger(/^blubb\//);
    });
});
ava_1.default('createRootMenuTrigger throws when not ending with /', t => {
    t.throws(() => {
        path_1.createRootMenuTrigger(/^blubb/);
    }, { message: /root menu trigger.+\// });
});
ava_1.default('createRootMenuTrigger throws when not starting with ^', t => {
    t.throws(() => {
        path_1.createRootMenuTrigger(/blubb\//);
    }, { message: /root menu trigger.+\^/ });
});
ava_1.default('createRootMenuTrigger throws when raw string contains multiple slashes /', t => {
    t.throws(() => {
        path_1.createRootMenuTrigger('some/stuff/');
    }, { message: /root menu trigger.+exactly one slash/ });
});
ava_1.default('createRootMenuTrigger throws when it matches multiple slashes /', t => {
    t.throws(() => {
        path_1.createRootMenuTrigger(/^.+\//);
    }, { message: /root menu trigger.+exactly one slash/ });
});
function combineTriggerMacro(t, parent, child, expected) {
    t.deepEqual(path_1.combineTrigger(parent, child), expected);
}
combineTriggerMacro.title = (_title, parent, child, expected) => `combineTrigger ${String(parent)} with ${String(child)} is ${String(expected)}`;
ava_1.default(combineTriggerMacro, /^\//, 'foo', /^\/foo/);
ava_1.default(combineTriggerMacro, /^\//, /foo/, /^\/foo/);
ava_1.default(combineTriggerMacro, /^\//, /foo\//, /^\/foo\//);
ava_1.default(combineTriggerMacro, /^\//, /[^/]+/, /^\/[^/]+/);
ava_1.default(combineTriggerMacro, /^\//i, 'foo', /^\/foo/i);
ava_1.default(combineTriggerMacro, /^\//i, /foo/, /^\/foo/i);
ava_1.default('combineTrigger fails when not beginning with ^', t => {
    t.throws(() => path_1.combineTrigger(/\/whatever\//, /whatever/), { message: /begin from start/ });
});
ava_1.default('combineTrigger fails when parent is not ending with /', t => {
    t.throws(() => path_1.combineTrigger(/^\/whatever/, /whatever/), { message: /end with \// });
});
ava_1.default('combineTrigger fails when child has flags/', t => {
    t.throws(() => path_1.combineTrigger(/^\/whatever\//, /whatever/i), { message: /flags/ });
    t.throws(() => path_1.combineTrigger(/^\/whatever\//, { source: 'whatever', flags: 'i' }), { message: /flags/ });
});
ava_1.default('ensureTriggerLastChild throws when not ending with $', t => {
    t.throws(() => {
        path_1.ensureTriggerLastChild(/blubb/);
    });
    t.throws(() => {
        path_1.ensureTriggerLastChild('blubb');
    });
    t.notThrows(() => {
        path_1.ensureTriggerLastChild(/blubb$/);
    });
    t.notThrows(() => {
        path_1.ensureTriggerLastChild('blubb$');
    });
});
ava_1.default('ensureTriggerChild throws when being somewhat relative', t => {
    t.throws(() => {
        path_1.ensureTriggerChild(/..$/);
    });
    t.throws(() => {
        path_1.ensureTriggerChild('..$');
    });
    t.throws(() => {
        path_1.ensureTriggerChild(/more than\/one deep$/);
    });
    t.throws(() => {
        path_1.ensureTriggerChild('more than/one deep$');
    });
    t.throws(() => {
        path_1.ensureTriggerChild(/\/relative to root$/);
    });
    t.throws(() => {
        path_1.ensureTriggerChild('/relative to root$');
    });
});
ava_1.default('ensurePathMenu accepts correct paths', t => {
    t.notThrows(() => {
        path_1.ensurePathMenu('path/');
    });
});
ava_1.default('ensurePathMenu throws when empty', t => {
    t.throws(() => {
        path_1.ensurePathMenu('');
    }, { message: /empty string/ });
});
ava_1.default('ensurePathMenu throws when not ending with slash', t => {
    t.throws(() => {
        path_1.ensurePathMenu('path');
    }, { message: /end with \// });
});
//# sourceMappingURL=path.test.js.map